
Given an F-Algebra, For example

data Arith x where
  Zero:: Arith x
  Succ:: x -> Arith x
  Add:: x -> x -> Arith x
  Mutl:: x -> x -> Arith x


data Boolean x where
  Not:: x -> Boolean x
  And:: x -> x -> Boolean x
  Or:: x -> x -> Boolean x
  T:: Boolean x
  F:: Boolean x


And a Meaning function: [F| _ |] :: (F x -> x)

meanA :: Arith Int -> Int
meanA Zero = 0
meanA (Succ x) = 1 + x
meanA (Add x y ) = x + y
meanA (Mult x y) = x * y

meanB:: Boolean Bool -> Bool
meanB T = True
meanB F = False
meanB (Not x) = not x
meanB (And x y ) = x && y
menaB (Or x y ) = x || y


Every F-Algebra supports a free algebra (i.e. free of non trivial equivalences)
called the initial algebra.


data Init F :: Set where
  In:: (F (Init F)) -> Init F
  
  
Note that "In" is a trivial meaning function.

----------------------------------------------------------

Let (x = y) be propositional equality
The define 

data Eq {x y} :: Set -> Set where
 E:: ( [F| x |] = [F| y|] ) -> Eq F (x=y)
 
Then a function :  (x:Init F) -> (y: Init F,Eq F (x==y))

g (In (Add x (In Zero))) = (x,E p)
g (In (Add x (In (Succ y)))) = (In(Succ(Add x y)),E q)
g x = (x,E refl)


Wraps up a transformation function with proofs that the meanings are preserved.
Such a function induces a "term-rewriting" function over types (Init F)

We want a generic function (perhaps parameterized by a strategy)

Desc F -> (Init F) -> (Init F)


----------------------------------------------------
Now let (Term:: Set -> Set) by the reflective Code that
internalizes terms in the language.  There exits generic functions

reify:: Type t -> t -> Term t
 or     t:Type -> [| t |] -> Term [| t |]

reflect:: Type t -> Term t -> t

reifyF:: Desc F -> Term (Init F) -> Maybe (Init F)

Using these functions one can build generic transformations
that

1) Pull a value into a term
2) Pull some Terms into (Init F)
3) Transform (Init F) to meaning preserved (Init F)
4) Use a strategy (tactic) to control how (3) is done
5) Push the meaning preserved (Init F) back into a Term







 
